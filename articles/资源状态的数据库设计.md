###起因 

早一段时期的时候，对学子的数据库schemas作了一些修改，修改内容包括信息
的表添加isdeleted字段，此外重灾区是Organization表，添加了isdeleted,isbaned
这两个字段等。

之所以对数据库表结构进行调整添加这些字段是因为基本上所有的应用都是不提倡对
数据进行硬删除，也就是直接将数据从数据库中删除，或者说调用SQL语句中的delete
语句。不提倡是因为：

* 对数据的硬删除往往会导致复杂的联级删除，比如如果你要删除的一行数据为管理员
表中的一个**管理员**，但是之前其他表的数据例如公告发布表存储的**公告发布者外
键**指向该行数据。这时为了成功进行对该行数据的删除你不得不对这些**公告发布者
外键**为该管理员id的数据重置该外键。同样也有其他数据会与之关联，这样你要进行
的操作更加复杂，无疑极大地增加了业务的复杂性。

* 数据库中的数据既然存在过，那就必然有其用处，就不应该删掉。一个例子是员工管
理系统中，如果一位员工被解雇了，是不是意味着他的数据就要被删掉？但是后续的业
务也是存在的，比如要对员工的解雇金进行记录，所以将其删除是不合理的做法。

那硬删除不提倡，那要怎么做？常见的做法就是上面提及到的，给每一行数据添加一个
字段。比如常见的isdeleted，这样如果要将所有员工的数据打印出来，如果不想浪费纸
张将被解雇的员工的资料打印出来，那可对isdeleted字段进行判断然后决定是否打印。
这个就是所谓的软删除。

###深入

软删除很好的保存了数据，解决了硬删除带来的联级删除的问题。但是通过上面提及的对
学子数据库schemas的修改，我们可以发现对organization表的修改需要添加两个字段，然
后再考虑下user表。为了达到软删除，user可能有isdeleted，isbaned，isactived这三个
字段，然后如果考虑不同的系统中复杂的业务需求可能需要添加的字段更多。这么一堆的
isXXX看起来真的一点都不优雅。并且在后端处理的时候对这些字段的判断明显要多了许多。

后来某天，突然想到，如果我们将一行数据作为资源，那这些所有的isXXX字段所表达的意
思是共同的：标示这个资源的状态。

如果这样的话，为什么我们不使用一个字段XXXstatus来表示资源状态呢？比如user_status，
存储该行数据资源的状态，然后在后端代码对资源的状态进行常量的定义，比如:

<pre>
#php code

const COMMOM    = 1;
const DELETED   = 0;
const UNACTIVED =-1; 
</pre>

这样，不同的实体可以定义各自的资源状态，然后对资源状态进行不同的判，进行不同的
的操作。还是员工管理系统中打印所有现任员工资料这个业务例子，进行这样的设计后，我
们可以只需要判断员工的状态是否为COMMOM即可，至于其他被解雇，停职留任，留任辞职之
类乱七八糟的状态员工资料就完全不需要考虑。当然我们的数据库设计也不会被各种isXXX
充斥了。

###再深入

状态模式.待补充

###补充

* 最后突然觉得上面那种做法其实有个弊端。毕竟数据库是用来存储数据资源的，单纯地以int的形式
存储的资源状态对于没有获得代码只有数据库的人来说，是不明显可见的，也就是对数据
库进行其他处理的人面对这种设计可能会有抓狂的冲动。但是从另外一方面来说，XXX_status的方
式可以避免在系统运行过程中，资源的状态产生了变种或者添加，需要直接修改数据库schemas的情
况发生。可能不同人有不同的考虑，当然，如果有一份状态配置文件可能这个问题也会消失。

* 那天晚上有童鞋提及到的XXX_status字段使用二进制，我后来想了想觉得这种做法有些问题。首先
第一个问题是，不同的实体有不同的状态，而且可能在业务的发展中会出现更多的状态，但是数据库
在初期的设计中是很难将所有的情况考虑到的，这样xxx_status字段的二进制码长度定义要么可能过
长，要么可能过短。然后是对二进制码的判断比对int的类型数据判断复杂了。还有如果采用二进制码
的方式，表示的是状态有可能并存，那又会引发多状态的处理问题及逻辑问题。最后如果采用二进制
码形式，在外部同样需要对二进制位进行定义，因为如果不定义的话那也太隐晦了，所以为啥不直接
使用int类型数据进行枚举常量的定义呢？当然可能有哪里我没有考虑清楚，所以欢迎讨论:-).

###相关阅读

* 状态模式 [[http://en.wikipedia.org/wiki/State_pattern statePattern]]
